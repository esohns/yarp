
// -------------------------------- * * * -------------------------------- //
// PLEASE NOTE: this file was/is generated by XML2CppCode 0.1
// -------------------------------- * * * -------------------------------- //

#pragma once
#ifndef RPG_SOUND_EVENT_H
#define RPG_SOUND_EVENT_H

enum RPG_Sound_Event
{
  EVENT_AMBIENT = 0,
  EVENT_MAIN_TITLE,
  EVENT_BELL,
  EVENT_CONDITION_ILL,
  EVENT_CONDITION_WEAK,
  EVENT_COUNTING,
  EVENT_DOOR_CLOSE,
  EVENT_DOOR_OPEN,
  EVENT_FOUNTAIN,
  EVENT_SWORD_HIT,
  EVENT_SWORD_MISS,
  EVENT_WALK,
  EVENT_XP_LEVELUP,
  //
  RPG_SOUND_EVENT_MAX,
  RPG_SOUND_EVENT_INVALID
};

#include "rpg_sound_exports.h"

#include <ace/Global_Macros.h>

#include <map>
#include <string>

typedef std::map<RPG_Sound_Event, std::string> RPG_Sound_EventToStringTable_t;
typedef RPG_Sound_EventToStringTable_t::const_iterator RPG_Sound_EventToStringTableIterator_t;

class RPG_Sound_Export RPG_Sound_EventHelper
{
 public:
  inline static void init()
  {
    myRPG_Sound_EventToStringTable.clear();
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_AMBIENT, ACE_TEXT_ALWAYS_CHAR("EVENT_AMBIENT")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_MAIN_TITLE, ACE_TEXT_ALWAYS_CHAR("EVENT_MAIN_TITLE")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_BELL, ACE_TEXT_ALWAYS_CHAR("EVENT_BELL")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_CONDITION_ILL, ACE_TEXT_ALWAYS_CHAR("EVENT_CONDITION_ILL")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_CONDITION_WEAK, ACE_TEXT_ALWAYS_CHAR("EVENT_CONDITION_WEAK")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_COUNTING, ACE_TEXT_ALWAYS_CHAR("EVENT_COUNTING")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_DOOR_CLOSE, ACE_TEXT_ALWAYS_CHAR("EVENT_DOOR_CLOSE")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_DOOR_OPEN, ACE_TEXT_ALWAYS_CHAR("EVENT_DOOR_OPEN")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_FOUNTAIN, ACE_TEXT_ALWAYS_CHAR("EVENT_FOUNTAIN")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_SWORD_HIT, ACE_TEXT_ALWAYS_CHAR("EVENT_SWORD_HIT")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_SWORD_MISS, ACE_TEXT_ALWAYS_CHAR("EVENT_SWORD_MISS")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_WALK, ACE_TEXT_ALWAYS_CHAR("EVENT_WALK")));
    myRPG_Sound_EventToStringTable.insert(std::make_pair(EVENT_XP_LEVELUP, ACE_TEXT_ALWAYS_CHAR("EVENT_XP_LEVELUP")));
  };

  inline static std::string RPG_Sound_EventToString(const RPG_Sound_Event& element_in)
  {
    std::string result;
    RPG_Sound_EventToStringTableIterator_t iterator = myRPG_Sound_EventToStringTable.find(element_in);
    if (iterator != myRPG_Sound_EventToStringTable.end())
      result = iterator->second;
    else
      result = ACE_TEXT_ALWAYS_CHAR("RPG_SOUND_EVENT_INVALID");

    return result;
  };

  inline static RPG_Sound_Event stringToRPG_Sound_Event(const std::string& string_in)
  {
    RPG_Sound_EventToStringTableIterator_t iterator = myRPG_Sound_EventToStringTable.begin();
    do
    {
      if (iterator->second == string_in)
        return iterator->first;

      iterator++;
    } while (iterator != myRPG_Sound_EventToStringTable.end());

    return RPG_SOUND_EVENT_INVALID;
  };

  static RPG_Sound_EventToStringTable_t myRPG_Sound_EventToStringTable;

 private:
  ACE_UNIMPLEMENTED_FUNC(RPG_Sound_EventHelper());
  ACE_UNIMPLEMENTED_FUNC(RPG_Sound_EventHelper(const RPG_Sound_EventHelper&));
  ACE_UNIMPLEMENTED_FUNC(RPG_Sound_EventHelper& operator=(const RPG_Sound_EventHelper&));
};

#endif
